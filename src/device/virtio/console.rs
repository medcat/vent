use byteorder::{ByteOrder, LittleEndian};
use device::pci::{Address, Pci};
use device::Device;
use kvm;
use std::sync::Mutex;
use virtio::Virtio;

#[cfg_attr(rustfmt, rustfmt_skip)]
static DEFAULT_PCI_CONFIG: &[u8] = &[
    0xf4, 0x1a, 0x43, 0x10, // 0x00
    0x00, 0x00, 0x10, 0x00, // 0x04
    0x00, 0x00, 0x80, 0x07, // 0x08
    0x00, 0x00, 0x00, 0x00, // 0x0c
    0x00, 0x00, 0x00, 0x00, // 0x10, BAR0
    0x00, 0x00, 0x00, 0x00, // 0x14, BAR1
    0x00, 0x00, 0x00, 0x00, // 0x18, BAR2
    0x00, 0x00, 0x00, 0x00, // 0x1c, BAR3
    0x00, 0x00, 0x00, 0x00, // 0x20, BAR4
    0x00, 0x00, 0x00, 0x00, // 0x24, BAR5
    0x00, 0x00, 0x00, 0x00, // 0x28
    0x00, 0x00, 0x00, 0x00, // 0x2c
    0x00, 0x00, 0x00, 0x00, // 0x30
    0x41, 0x00, 0x00, 0x00, // 0x34
    0x00, 0x00, 0x00, 0x00, // 0x38
    0x00, 0x00, 0x00, 0x00, // 0x40
    // I think this is where the capability list points.
    0x09, 0x58, 0x14, 0x05, // 0x44, struct virtio_pci_cfg_cap (vndr, next, len, type)
    0x00, 0x00, 0x00, 0x00, // 0x48, (bar, pad, pad, pad)
    0x00, 0x00, 0x00, 0x00, // 0x4c, (offset)
    0x00, 0x00, 0x00, 0x00, // 0x50, (length)
    0x00, 0x00, 0x00, 0x00, // 0x54
    // 0x09, 0x--, 0x--, 0x01, // 0x58, struct virtio_pci_common_cfg (vndr, next, len, type)
    // 0x00, 0x00, 0x00, 0x00, // 0x5c, (bar, pad, pad, pad)
    // 0x00, 0x00, 0x00, 0x00, // 0x60, (offset)
    // 0x00, 0x00, 0x00, 0x00, // 0x64, (length)
    // 0x00, 0x00, 0x00, 0x00, // 0x68, (device_feature_select)
    // 0x00, 0x00, 0x00, 0x00, // 0x6c, ()
];

#[derive(Debug)]
pub struct Console(Mutex<Vec<u8>>);

impl Console {
    pub fn new() -> Console {
        Console(Mutex::new(DEFAULT_PCI_CONFIG.to_owned()))
    }
}

impl Device for Console {
    fn request(&self) -> Vec<kvm::core::IoAddress> {
        vec![]
    }
    fn handle(&self, _io: kvm::core::IoAction, _memory: &mut [u8]) -> Option<()> {
        None
    }
}

impl Pci for Console {
    fn config_read(&self, address: Address) -> Option<u32> {
        let space = self.0.lock().unwrap();
        let lower = address.register() as usize;
        let upper = lower + 4;
        if space.len() < upper {
            Some(LittleEndian::read_u32(&space[lower..upper]))
        } else {
            None
        }
    }

    fn config_write(&self, address: Address, _value: u32) -> Option<()> {
        warn!("attempted write of {:?}", address);
        None
    }
}

impl Virtio for Console {}
